// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "../../../node_modules/rescript/lib/es6/curry.js";
import * as React from "react";
import * as Wagmi from "wagmi";
import * as Sidebar from "./components/Sidebar.js";
import * as AuthServer from "./AuthServer.js";
import * as Caml_option from "../../../node_modules/rescript/lib/es6/caml_option.js";
import LodashMerge from "lodash.merge";
import * as Core__Promise from "../../../node_modules/@rescript/core/src/Core__Promise.js";
import * as DiscordServer from "./DiscordServer.js";
import * as React$1 from "@remix-run/react";
import * as JsxRuntime from "react/jsx-runtime";
import * as Rainbowkit from "@rainbow-me/rainbowkit";

import rainbowKit from "@rainbow-me/rainbowkit/styles.css"
;

import proSidebar from "react-pro-sidebar/dist/css/styles.css"
;

import {
  getDefaultWallets,
} from "@rainbow-me/rainbowkit";
import { createClient, configureChains } from "wagmi"
import { mainnet} from 'wagmi/chains'
import { alchemyProvider } from 'wagmi/providers/alchemy'
import { publicProvider } from 'wagmi/providers/public'
import { jsonRpcProvider } from '@wagmi/core/providers/jsonRpc'
;

var LodashMerge$1 = {};

function meta(param) {
  return {
          charset: "utf-8",
          title: "Bright ID Discord Command Center",
          viewport: "width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        };
}

function links(param) {
  return [
          {
            rel: "stylesheet",
            href: (require("./styles/app.css"))
          },
          {
            rel: "stylesheet",
            href: rainbowKit
          },
          {
            rel: "stylesheet",
            href: proSidebar
          }
        ];
}

var _idChain = {
  id: 74,
  name: "ID Chain",
  nativeCurrency: {
    name: "Eidi",
    symbol: "EIDI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: "https://idchain.one/rpc"
    }
  },
  blockExplorers: [{
      name: "Blockscout",
      url: "https://explorer.idchain.one/"
    }]
};

function loader(param) {
  return Core__Promise.$$catch(AuthServer.authenticator.isAuthenticated(param.request).then(function (user) {
                  return Promise.resolve({
                              maybeUser: (user == null) ? undefined : Caml_option.some(user),
                              rateLimited: false
                            });
                }), (function (error) {
                if (error.RE_EXN_ID === DiscordServer.DiscordRateLimited) {
                  return Promise.resolve({
                              maybeUser: undefined,
                              rateLimited: true
                            });
                } else {
                  return Promise.resolve({
                              maybeUser: undefined,
                              rateLimited: false
                            });
                }
              }));
}

var myTheme = LodashMerge(Rainbowkit.darkTheme(), {
      colors: {
        accentColor: "#ed7a5c"
      }
    });

var chainConfig = (configureChains(
    [mainnet, _idChain],
    [
      alchemyProvider({
        apiKey: "Klcw92W_rTgV55TL0zq972TFXTI1FieU",
        stallTimeout: 5_000
      }),
      jsonRpcProvider({
        rpc: (chain)  => ({ http: chain.rpcUrls.default.http })
      }),

    ]

  ));

var _defaultWallets = (getDefaultWallets({
    appName: "Bright ID Discord Command Center",
    chains: chainConfig.chains,
  }));

var wagmiClient = (createClient({
    autoConnect: true,
    connectors: _defaultWallets.connectors,
    provider: chainConfig.provider,
  }));

var state_userGuilds = [];

var state_botGuilds = [];

var state_after = "0";

var state_wagmiClient = Caml_option.some(wagmiClient);

var state_chains = chainConfig.chains;

var state = {
  userGuilds: state_userGuilds,
  botGuilds: state_botGuilds,
  after: state_after,
  loadingGuilds: true,
  wagmiClient: state_wagmiClient,
  chains: state_chains
};

function reducer(state, action) {
  switch (action.TAG | 0) {
    case /* AddBotGuilds */0 :
        return {
                userGuilds: state.userGuilds,
                botGuilds: state.botGuilds.concat(action._0),
                after: state.after,
                loadingGuilds: state.loadingGuilds,
                wagmiClient: state.wagmiClient,
                chains: state.chains
              };
    case /* UserGuilds */1 :
        return {
                userGuilds: action._0,
                botGuilds: state.botGuilds,
                after: state.after,
                loadingGuilds: state.loadingGuilds,
                wagmiClient: state.wagmiClient,
                chains: state.chains
              };
    case /* SetAfter */2 :
        return {
                userGuilds: state.userGuilds,
                botGuilds: state.botGuilds,
                after: action._0,
                loadingGuilds: state.loadingGuilds,
                wagmiClient: state.wagmiClient,
                chains: state.chains
              };
    case /* SetLoadingGuilds */3 :
        return {
                userGuilds: state.userGuilds,
                botGuilds: state.botGuilds,
                after: state.after,
                loadingGuilds: action._0,
                wagmiClient: state.wagmiClient,
                chains: state.chains
              };
    case /* SetWagmiClient */4 :
        return {
                userGuilds: state.userGuilds,
                botGuilds: state.botGuilds,
                after: state.after,
                loadingGuilds: state.loadingGuilds,
                wagmiClient: action._0,
                chains: state.chains
              };
    case /* SetChains */5 :
        return {
                userGuilds: state.userGuilds,
                botGuilds: state.botGuilds,
                after: state.after,
                loadingGuilds: state.loadingGuilds,
                wagmiClient: state.wagmiClient,
                chains: action._0
              };
    
  }
}

function Root$default(props) {
  var match = React$1.useLoaderData();
  var match$1 = React.useState(function () {
        return false;
      });
  var setIsSidebarVisible = match$1[1];
  var isSidebarVisible = match$1[0];
  var fetcher = React$1.useFetcher();
  var match$2 = React.useReducer(reducer, state);
  var dispatch = match$2[1];
  var state$1 = match$2[0];
  React.useEffect((function () {
          var after = state$1.after;
          if (after !== undefined) {
            var match = fetcher.type;
            switch (match) {
              case "done" :
                  var data = fetcher.data;
                  if (data == null) {
                    Curry._1(dispatch, {
                          TAG: /* SetLoadingGuilds */3,
                          _0: false
                        });
                    Curry._1(dispatch, {
                          TAG: /* SetAfter */2,
                          _0: undefined
                        });
                  } else {
                    var match$1 = data.userGuilds;
                    if (match$1.length !== 0) {
                      Curry._1(dispatch, {
                            TAG: /* UserGuilds */1,
                            _0: data.userGuilds
                          });
                    }
                    var match$2 = data.botGuilds;
                    if (match$2.length !== 0) {
                      Curry._1(dispatch, {
                            TAG: /* AddBotGuilds */0,
                            _0: data.botGuilds
                          });
                    } else {
                      Curry._1(dispatch, {
                            TAG: /* SetAfter */2,
                            _0: undefined
                          });
                    }
                    if (state$1.after === data.after) {
                      Curry._1(dispatch, {
                            TAG: /* SetAfter */2,
                            _0: undefined
                          });
                      Curry._1(dispatch, {
                            TAG: /* SetLoadingGuilds */3,
                            _0: false
                          });
                    } else {
                      Curry._1(dispatch, {
                            TAG: /* SetAfter */2,
                            _0: data.after
                          });
                      fetcher.load("/Root_FetchGuilds?after=" + data.after + "");
                    }
                  }
                  break;
              case "init" :
                  fetcher.load("/Root_FetchGuilds?after=" + after + "");
                  Curry._1(dispatch, {
                        TAG: /* SetLoadingGuilds */3,
                        _0: true
                      });
                  break;
              default:
                
            }
          }
          
        }), [fetcher]);
  var guilds = state$1.userGuilds.filter(function (userGuild) {
        return state$1.botGuilds.findIndex(function (botGuild) {
                    return botGuild.id === userGuild.id;
                  }) !== -1;
      });
  var handleIsSidebarVisible = function (value) {
    Curry._1(setIsSidebarVisible, (function (_prev) {
            return value;
          }));
  };
  var match$3 = state$1.wagmiClient;
  var match$4 = state$1.chains;
  return JsxRuntime.jsxs("html", {
              children: [
                JsxRuntime.jsxs("head", {
                      children: [
                        JsxRuntime.jsx("meta", {
                              charSet: "utf-8"
                            }),
                        JsxRuntime.jsx("meta", {
                              content: "width=device-width,initial-scale=1",
                              name: "viewport"
                            }),
                        JsxRuntime.jsx(React$1.Meta, {}),
                        JsxRuntime.jsx(React$1.Links, {})
                      ]
                    }),
                JsxRuntime.jsxs("body", {
                      children: [
                        match$3 !== undefined && match$4 !== undefined ? JsxRuntime.jsx(Wagmi.WagmiConfig, {
                                client: Caml_option.valFromOption(match$3),
                                children: JsxRuntime.jsx(Rainbowkit.RainbowKitProvider, {
                                      chains: match$4,
                                      theme: myTheme,
                                      children: JsxRuntime.jsxs("div", {
                                            children: [
                                              match.maybeUser !== undefined ? JsxRuntime.jsx(Sidebar.make, {
                                                      isSidebarVisible: isSidebarVisible,
                                                      handleIsSidebarVisible: handleIsSidebarVisible,
                                                      guilds: guilds,
                                                      loadingGuilds: state$1.loadingGuilds
                                                    }) : JsxRuntime.jsx(JsxRuntime.Fragment, {}),
                                              JsxRuntime.jsx(React$1.Outlet, {
                                                    context: {
                                                      isSidebarVisible: isSidebarVisible,
                                                      handleIsSidebarVisible: handleIsSidebarVisible,
                                                      rateLimited: match.rateLimited,
                                                      guilds: guilds
                                                    }
                                                  })
                                            ],
                                            className: "flex h-screen w-screen"
                                          })
                                    })
                              }) : JsxRuntime.jsx(JsxRuntime.Fragment, {}),
                        JsxRuntime.jsx(React$1.ScrollRestoration, {}),
                        JsxRuntime.jsx(React$1.Scripts, {}),
                        process.env.NODE_ENV === "development" ? JsxRuntime.jsx(React$1.LiveReload, {}) : null
                      ],
                      className: "h-screen w-screen bg-dark"
                    })
              ]
            });
}

export function ErrorBoundary({ error }) {
  console.error(error);
  return (
    <html>
      <head>
        <title>Oh no!</title>
        <React$1.Meta />
        <React$1.Links />
      </head>
      <body>
        <p className="text-center">Something went wrong!</p>
        <p className="text-center">BrightID command center is still in Beta. Try reloading the page!</p>
        <React$1.Scripts />
      </body>
    </html>
  );
}
;

var $$default = Root$default;

export {
  LodashMerge$1 as LodashMerge,
  meta ,
  links ,
  _idChain ,
  loader ,
  myTheme ,
  chainConfig ,
  _defaultWallets ,
  wagmiClient ,
  state ,
  reducer ,
  $$default ,
  $$default as default,
}
/*  Not a pure module */
