// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Env from "./Env.mjs";
import * as Uuid from "uuid";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as $$Promise from "@ryyppy/rescript-promise/src/Promise.mjs";
import * as Constants from "./Constants.mjs";
import * as Endpoints from "./Endpoints.mjs";
import * as Gist$Utils from "@brightidbot/utils/src/Gist.mjs";
import * as DiscordJs from "discord.js";
import NodeFetch from "node-fetch";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Commands_Help from "./commands/Commands_Help.mjs";
import * as Commands_Role from "./commands/Commands_Role.mjs";
import * as Buttons_Verify from "./buttons/Buttons_Verify.mjs";
import * as Commands_Guild from "./commands/Commands_Guild.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Commands_Invite from "./commands/Commands_Invite.mjs";
import * as Commands_Verify from "./commands/Commands_Verify.mjs";
import * as Json$JsonCombinators from "@glennsl/rescript-json-combinators/src/Json.mjs";
import * as UpdateOrReadGistMjs from "./updateOrReadGist.mjs";
import * as Json_Decode$JsonCombinators from "@glennsl/rescript-json-combinators/src/Json_Decode.mjs";

var RequestHandlerError = /* @__PURE__ */Caml_exceptions.create("Bot.RequestHandlerError");

var GuildNotInGist = /* @__PURE__ */Caml_exceptions.create("Bot.GuildNotInGist");

globalThis.fetch = NodeFetch;

var NodeFetchPolyfill = {};

var $$Response = {};

var UUID = {};

function contextId(field) {
  return {
          unique: field.required("unique", Json_Decode$JsonCombinators.bool),
          app: field.required("app", Json_Decode$JsonCombinators.string),
          context: field.required("context", Json_Decode$JsonCombinators.string),
          contextIds: field.required("contextIds", Json_Decode$JsonCombinators.array(Json_Decode$JsonCombinators.string)),
          timestamp: field.required("timestamp", Json_Decode$JsonCombinators.$$int)
        };
}

function data(field) {
  var __x = Json_Decode$JsonCombinators.object(contextId);
  return {
          data: field.required("data", __x)
        };
}

var brightIdObject = Json_Decode$JsonCombinators.object(data);

function error(field) {
  return {
          error: field.required("error", Json_Decode$JsonCombinators.bool),
          errorNum: field.required("errorNum", Json_Decode$JsonCombinators.$$int),
          errorMessage: field.required("errorMessage", Json_Decode$JsonCombinators.string),
          code: field.required("code", Json_Decode$JsonCombinators.$$int)
        };
}

var error$1 = Json_Decode$JsonCombinators.object(error);

var Decode = {
  contextId: contextId,
  data: data,
  brightIdObject: brightIdObject,
  error: error$1
};

function updateGist(prim0, prim1) {
  return UpdateOrReadGistMjs.updateGist(prim0, prim1);
}

Env.createEnv(undefined);

var envConfig = Env.getConfig(undefined);

var envConfig$1;

if (envConfig.TAG === /* Ok */0) {
  envConfig$1 = envConfig._0;
} else {
  throw {
        RE_EXN_ID: Env.EnvError,
        _1: envConfig._0,
        Error: new Error()
      };
}

var options = {
  intents: [
    "GUILDS",
    "GUILD_MESSAGES",
    "GUILD_MEMBERS"
  ]
};

var client = new DiscordJs.Client(options);

var commands = new DiscordJs.Collection();

var buttons = new DiscordJs.Collection();

commands.set(Commands_Help.data.name, {
              data: Commands_Help.data,
              execute: Commands_Help.execute
            }).set(Commands_Verify.data.name, {
            data: Commands_Verify.data,
            execute: Commands_Verify.execute
          }).set(Commands_Role.data.name, {
          data: Commands_Role.data,
          execute: Commands_Role.execute
        }).set(Commands_Invite.data.name, {
        data: Commands_Invite.data,
        execute: Commands_Invite.execute
      }).set(Commands_Guild.data.name, {
      data: Commands_Guild.data,
      execute: Commands_Guild.execute
    });

buttons.set(Buttons_Verify.customId, {
      customId: Buttons_Verify.customId,
      execute: Buttons_Verify.execute
    });

var guild = Json_Decode$JsonCombinators.object(function (field) {
      return {
              role: field.optional("role", Json_Decode$JsonCombinators.string),
              name: field.optional("name", Json_Decode$JsonCombinators.string),
              inviteLink: field.optional("inviteLink", Json_Decode$JsonCombinators.string),
              roleId: field.optional("roleId", Json_Decode$JsonCombinators.string)
            };
    });

var brightIdGuilds = Json_Decode$JsonCombinators.dict(guild);

function updateGistOnGuildCreate(guild, roleId) {
  var guildId = guild.id;
  return UpdateOrReadGistMjs.updateGist(guildId, {
              name: guild.name,
              role: "Verified",
              roleId: roleId
            });
}

function onGuildCreate(guild) {
  var roleManager = guild.roles;
  roleManager.create({
          name: "Verified",
          color: "ORANGE",
          reason: "Create a role to mark verified users with BrightID"
        }).then(function (role) {
        return updateGistOnGuildCreate(guild, role.id);
      });
}

function onInteraction(interaction) {
  var isCommand = interaction.isCommand();
  var isButton = interaction.isButton();
  var user = interaction.user;
  if (isCommand) {
    if (isButton) {
      console.error("Bot.res: Unknown interaction");
      return ;
    }
    var commandName = interaction.commandName;
    var command = commands.get(commandName);
    if (command == null) {
      console.error("Bot.res: Command not found");
    } else {
      Curry._1(command.execute, interaction).then(function (param) {
            return Promise.resolve((console.log("Successfully served the command " + commandName + " for " + user.username + ""), undefined));
          });
    }
    return ;
  }
  if (isButton) {
    var buttonCustomId = interaction.customId;
    var button = buttons.get(buttonCustomId);
    if (button == null) {
      console.error("Bot.res: Button not found");
    } else {
      Curry._1(button.execute, interaction).then(function (param) {
            return Promise.resolve((console.log("Successfully served button press \"" + buttonCustomId + "\" for " + user.username + ""), undefined));
          });
    }
    return ;
  }
  console.error("Bot.res: Unknown interaction");
}

function onGuildDelete(guild) {
  var config = Gist$Utils.makeGistConfig(Gist$Utils.envConfig.gistId, "guildData.json", Gist$Utils.envConfig.githubAccessToken);
  var guildId = guild.id;
  $$Promise.$$catch(Gist$Utils.ReadGist.content(config, brightIdGuilds).then(function (content) {
            var brightIdGuild = Js_dict.get(content, guildId);
            if (brightIdGuild === undefined) {
              return Promise.resolve((console.log("No role to delete for guild " + guildId + ""), undefined));
            }
            var __x = guild.id;
            return Gist$Utils.UpdateGist.removeEntry(content, __x, config).then(function (param) {
                        return Promise.resolve(undefined);
                      });
          }), (function (err) {
          console.error(err);
          return Promise.resolve(undefined);
        }));
}

function onGuildMemberAdd(guildMember) {
  var uuid = Uuid.v5(guildMember.id, envConfig$1.uuidNamespace);
  var endpoint = "" + Endpoints.brightIdVerificationEndpoint + "/" + Constants.context + "/" + uuid + "?timestamp=seconds";
  var params = {
    method: "GET",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    timestamp: 60000
  };
  $$Promise.$$catch(globalThis.fetch(endpoint, params).then(function (res) {
              return res.json();
            }).then(function (json) {
            var match = Json$JsonCombinators.decode(json, brightIdObject);
            var match$1 = Json$JsonCombinators.decode(json, error$1);
            if (match.TAG !== /* Ok */0) {
              if (match$1.TAG === /* Ok */0) {
                return Promise.resolve((console.log(match$1._0.errorMessage), undefined));
              } else {
                return Promise.reject({
                            RE_EXN_ID: Json_Decode$JsonCombinators.DecodeError,
                            _1: match._0
                          });
              }
            }
            if (!match._0.data.unique) {
              return Promise.resolve((console.log("User " + guildMember.displayName + " is not unique"), undefined));
            }
            var __x = Gist$Utils.makeGistConfig(envConfig$1.gistId, "guildData.json", envConfig$1.githubAccessToken);
            return Gist$Utils.ReadGist.content(__x, brightIdGuilds).then(function (content) {
                        var guild = guildMember.guild;
                        var guildId = guild.id;
                        var brightIdGuild = Belt_Option.getExn(Js_dict.get(content, guildId));
                        var roleId = Belt_Option.getExn(brightIdGuild.roleId);
                        var role = Belt_Option.getExn(Caml_option.nullable_to_opt(guild.roles.cache.get(roleId)));
                        var guildMemberRoleManager = guildMember.roles;
                        guildMemberRoleManager.add(role, "User is already verified by BrightID");
                        return Promise.resolve(undefined);
                      });
          }), (function (err) {
          console.error(err);
          return Promise.resolve(undefined);
        }));
}

client.on("ready", (function (param) {
        console.log("Logged In");
      }));

client.on("guildCreate", onGuildCreate);

client.on("interactionCreate", onInteraction);

client.on("guildDelete", onGuildDelete);

client.on("guildMemberAdd", onGuildMemberAdd);

client.login(envConfig$1.discordApiToken);

var brightIdVerificationEndpoint = Endpoints.brightIdVerificationEndpoint;

var context = Constants.context;

export {
  brightIdVerificationEndpoint ,
  context ,
  RequestHandlerError ,
  GuildNotInGist ,
  NodeFetchPolyfill ,
  $$Response ,
  UUID ,
  Decode ,
  updateGist ,
  envConfig$1 as envConfig,
  options ,
  client ,
  commands ,
  buttons ,
  guild ,
  brightIdGuilds ,
  updateGistOnGuildCreate ,
  onGuildCreate ,
  onInteraction ,
  onGuildDelete ,
  onGuildMemberAdd ,
}
/*  Not a pure module */
